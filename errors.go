package ngrok

import (
	"fmt"
	"net/url"
	"regexp"
)

type ngrokError interface {
	Error() string
	ErrorCode() string
}

// Errors arising from authentication failure.
type errAuthFailed struct {
	// Whether the error was generated by the remote server, or in the sending
	// of the authentication request.
	Remote bool
	// The underlying error.
	Inner error
}

func (e errAuthFailed) Error() string {
	var msg string
	if e.Remote {
		msg = "authentication failed"
	} else {
		msg = "failed to send authentication request"
	}

	return fmt.Sprintf("%s: %v", msg, e.Inner)
}

func (e errAuthFailed) Unwrap() error {
	return e.Inner
}

func (e errAuthFailed) Is(target error) bool {
	_, ok := target.(errAuthFailed)
	return ok
}

func (e errAuthFailed) ErrorCode() string {
	errMsg := e.Inner.Error()

	// Find the number in the format of ERR_NGROK_(\d+).
	reg := regexp.MustCompile(`ERR_NGROK_(\d+)`)
	matches := reg.FindStringSubmatch(errMsg)
	if len(matches) == 2 {
		return matches[1]
	}

	return ""
}

// The error returned by [Tunnel]'s [net.Listener.Accept] method.
type errAcceptFailed struct {
	// The underlying error.
	Inner error
}

func (e errAcceptFailed) Error() string {
	return fmt.Sprintf("failed to accept connection: %v", e.Inner)
}

func (e errAcceptFailed) Unwrap() error {
	return e.Inner
}

func (e errAcceptFailed) Is(target error) bool {
	_, ok := target.(errAcceptFailed)
	return ok
}

func (e errAcceptFailed) ErrorCode() string {
	errMsg := e.Inner.Error()

	// Find the number in the format of ERR_NGROK_(\d+).
	reg := regexp.MustCompile(`ERR_NGROK_(\d+)`)
	matches := reg.FindStringSubmatch(errMsg)
	if len(matches) == 2 {
		return matches[1]
	}

	return ""
}

// Errors arising from a failure to start a tunnel.
type errListen struct {
	// The underlying error.
	Inner error
}

func (e errListen) Error() string {
	return fmt.Sprintf("failed to start tunnel: %v", e.Inner)
}

func (e errListen) Unwrap() error {
	return e.Inner
}

func (e errListen) Is(target error) bool {
	_, ok := target.(errListen)
	return ok
}


func (e errListen) ErrorCode() string {
	errMsg := e.Inner.Error()

	// Find the number in the format of ERR_NGROK_(\d+).
	reg := regexp.MustCompile(`ERR_NGROK_(\d+)`)
	matches := reg.FindStringSubmatch(errMsg)
	if len(matches) == 2 {
		return matches[1]
	}

	return ""
}

// Errors arising from a failure to construct a [golang.org/x/net/proxy.Dialer] from a [url.URL].
type errProxyInit struct {
	// The provided proxy URL.
	URL *url.URL
	// The underlying error.
	Inner error
}

func (e errProxyInit) Error() string {
	return fmt.Sprintf("failed to construct proxy dialer from \"%s\": %v", e.URL.String(), e.Inner)
}

func (e errProxyInit) Unwrap() error {
	return e.Inner
}

func (e errProxyInit) Is(target error) bool {
	_, ok := target.(errProxyInit)
	return ok
}

func (e errProxyInit) ErrorCode() string {
	errMsg := e.Inner.Error()

	// Find the number in the format of ERR_NGROK_(\d+).
	reg := regexp.MustCompile(`ERR_NGROK_(\d+)`)
	matches := reg.FindStringSubmatch(errMsg)
	if len(matches) == 2 {
		return matches[1]
	}

	return ""
}

// Error arising from a failure to dial the ngrok server.
type errSessionDial struct {
	// The address to which a connection was attempted.
	Addr string
	// The underlying error.
	Inner error
}

func (e errSessionDial) Error() string {
	return fmt.Sprintf("failed to dial ngrok server with address \"%s\": %v", e.Addr, e.Inner)
}

func (e errSessionDial) Unwrap() error {
	return e.Inner
}

func (e errSessionDial) Is(target error) bool {
	_, ok := target.(errSessionDial)
	return ok
}

func (e errSessionDial) ErrorCode() string {
	errMsg := e.Inner.Error()

	// Find the number in the format of ERR_NGROK_(\d+).
	reg := regexp.MustCompile(`ERR_NGROK_(\d+)`)
	matches := reg.FindStringSubmatch(errMsg)
	if len(matches) == 2 {
		return matches[1]
	}

	return ""
}